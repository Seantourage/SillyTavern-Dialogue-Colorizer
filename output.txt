ByRef.js 
/**
 * @template T
 */
export class ByRef {
    #getter;
    #setter;

    /**
     * 
     * @param {() => T} getter 
     * @param {((value: T) => void)=} [setter=null] 
     */
    constructor(getter, setter) {
        if (!getter) {
            throw new Error("Cannot create a ByRef without a valid getter.");
        }
        this.#getter = getter;
        this.#setter = setter || null;
    }

    /** Get or set the value of the referenced object. */
    get ref() {
        return this.#getter();
    }

    set ref(value) {
        if (this.isReadOnly) {
            throw new Error("Cannot set the value of a read-only reference.");
        }

        this.#setter(value);
    }

    /** Gets whether this ByRef is read-only. */
    get isReadOnly() {
        return !this.#setter;
    }

    /** Gets this ByRef as a new read-only ByRef. */
    asReadOnly() {
        return new ByRef(this.#getter);
    }

    /**
     * Creates a ByRef that can be used to read or write the value of a specified key.
     * @template TObject
     * @template {TObject[keyof TObject]} TValue
     * @param {TObject} object
     * @param {keyof any} key 
     * @returns {ByRef<TValue>}
     */
    static createKeyAccessor(object, key) {
        const getter = () => object[key];
        const setter = ((/** @type {TValue} */ value) => object[key] = value);

        return new ByRef(getter, setter);
    }
} 
 
color-utils.js 
import "./Vibrant.min.js";
import { waitForImage } from "./utils.js";

/** @type {VibrantConstructor} */
export const Vibrant = window["Vibrant"];

/**
 * Creates a Vibrant object from the given image.
 * 
 * @param {HTMLImageElement} image
 * @returns {Promise<VibrantObj>}
 */
export async function getImageVibrant(image) {
    const loadedImage = await waitForImage(image);
    return new Vibrant(loadedImage, 96, 6);
}

/**
 * Attempts to get a valid swatch from the list in the defined order, returning `null` if none are valid.
 * 
 * @param {VibrantSwatches} swatchesObject 
 * @param {...keyof VibrantSwatches} swatches 
 * @returns {VibrantSwatch?}
 */
export function getValidSwatch(swatchesObject, ...swatches) {
    for (const swatch of swatches) {
        if (swatchesObject.hasOwnProperty(swatch) && swatchesObject[swatch]){
            return swatchesObject[swatch];
        }
    }

    return null;
} 
 
dialogue-colorizer.html 
<div id="xdc-extension-settings" class="xdc-extension-settings">
    <div class="inline-drawer">
        <div class="inline-drawer-toggle inline-drawer-header">
            <b>Dialogue Colorizer</b>
            <div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>
        </div>
        <div class="inline-drawer-content">
            <div id="xdc-global_dialogue_settings" class="xdc-extension_block dc-flex-container dc-color-settings-group">
                <h4>Global Dialogue Settings</h4>
                <label for="xdc-chat_bubble_color_lightness" title="The lightness to use for the chat bubble color.">
                    Chat Bubble Lightness<span class="margin5 fa-solid fa-circle-info opacity50p"></span>
                    <input type="text" id="xdc-chat_bubble_color_lightness" name="xdc-chat_bubble_color_lightness" class="text_pole textarea_compact">
                </label>
            </div>
            <div id="xdc-char_dialogue_settings" class="xdc-extension_block dc-flex-container dc-color-settings-group">
                <div>
                    <label for="xdc-char_dialogue_settings_header" title="Dialogue settings for characters.">
                        <h4 id="xdc-char_dialogue_settings_header" name="xdc-char_dialogue_settings_header">
                            Character Dialogue Settings<span class="margin5 fa-solid fa-circle-info opacity50p"></span>
                        </h4>
                    </label>
                </div>
                <!-- 'Color Source Dropdown' created dynamically here -->
                <br/>
                <div>
                    <label for="xdc-char_static_color" title="The static color to use for character dialog if 'Color Source' is set to 'Static Color'.">
                        Static Color<span class="margin5 fa-solid fa-circle-info opacity50p"></span>
                    </label>
                    <!-- 'Static Color Picker Combo' created dynamically here -->
                </div>
            </div>
            <div id="xdc-persona_dialogue_settings" class="xdc-extension_block dc-flex-container dc-color-settings-group">
                <div>
                    <label for="xdc-persona_dialogue_settings_header" title="Dialogue settings for user personas.">
                        <h4 id="xdc-persona_dialogue_settings_header" name="xdc-persona_dialogue_settings_header">
                            Persona Dialogue Settings<span class="margin5 fa-solid fa-circle-info opacity50p"></span>
                        </h4>
                    </label>
                </div>
                <!-- 'Color Source Dropdown' created dynamically here -->
                <br/>
                <div>
                    <label for="xdc-persona_static_color" title="The static color to use for character dialog if 'Color Source' is set to 'Static Color'.">
                        Static Color<span class="margin5 fa-solid fa-circle-info opacity50p"></span>
                    </label>
                    <!-- 'Static Color Picker Combo' created dynamically here -->
                </div>
            </div>
        </div>
    </div>
</div> 
 
element-creators.js 
import { ColorizeSourceType, ColorizeTargetType } from "./index.js";
import { linkInputColorTextPicker } from "./utils.js";

/** @typedef {{value: any, text: string, description: string}} DropdownOptionObject */

/**
 * 
 * @param {string} templateId 
 * @param {boolean?} deep 
 * @returns {DocumentFragment}
 */
export function createTemplateClone(templateId, deep) {
    const tpl = /** @type {HTMLTemplateElement} */ (document.getElementById(templateId));
    return /** @type {DocumentFragment} */ (tpl.content.cloneNode(deep));
}

/**
 * @param {(textboxValue: string) => string?} textboxValueProcessor 
 * @param {(colorHex: string) => void} onColorChanged 
 * @returns 
 */
export function createColorTextPickerCombo(textboxValueProcessor, onColorChanged) {
    const textInput = document.createElement('input');
    textInput.className = "text_pole textarea_compact";
    textInput.type = "text";

    const pickerInput = document.createElement('input');
    pickerInput.className = "dc-color-picker";
    pickerInput.type = "color";

    const pickerWrapper = document.createElement('div');
    pickerWrapper.className = "dc-color-picker-wrapper";
    pickerWrapper.appendChild(pickerInput);

    const wrapper = document.createElement('div');
    wrapper.className = "dc-color-input-combo";
    wrapper.appendChild(pickerWrapper);
    wrapper.appendChild(textInput);

    linkInputColorTextPicker(pickerInput, textInput, textboxValueProcessor, onColorChanged);
    return wrapper;
}

/**
 * 
 * @param {string} id The ID to set on the created elements.
 * @param {DropdownOptionObject[]} optionObjects 
 * @param {string=} labelText The string for the label.
 * @param {string=} description The help text for the label and contents.
 * @param {((event: Event) => void)=} onChangedCallback The 'onchange' callback to add to the dropdown.
 * @returns {HTMLDivElement} The div containing the label and dropdown.
 */
export function createDropdownWithLabel(id, optionObjects, labelText, description, onChangedCallback) {
    const dropdownLabel = document.createElement('label');
    dropdownLabel.htmlFor = id;
    dropdownLabel.innerHTML = labelText;
    if (description) {
        dropdownLabel.title = description;
        dropdownLabel.innerHTML += `<span class="margin5 fa-solid fa-circle-info opacity50p"></span>`;
    }

    const dropdown = document.createElement('select');
    dropdown.id = id;
    dropdown.name = id;
    optionObjects.forEach((optionObj) => {
        const elemOption = document.createElement('option');
        elemOption.value = optionObj.value;
        elemOption.title = optionObj.description;
        elemOption.innerHTML = optionObj.text;
        dropdown.appendChild(elemOption);
    })

    if (onChangedCallback) {
        dropdown.addEventListener('change', onChangedCallback);
    }

    const wrapper = document.createElement('div');
    wrapper.appendChild(dropdownLabel);
    wrapper.appendChild(dropdown);
    return wrapper;
}

/**
 * 
 * @param {string} id The ID to set on the created elements.
 * @param {((event: Event) => void)=} onChangedCallback The 'onchange' callback to add to the dropdown.
 * @returns {HTMLDivElement} The div containing the label and dropdown.
 */
export function createColorSourceDropdown(id, onChangedCallback) {
    const options = [
        {
            value: ColorizeSourceType.AVATAR_VIBRANT, 
            text: "Avatar Vibrant", 
            description: "Use a vibrant color dynamically calculated from the character's avatar."
        },
        {
            value: ColorizeSourceType.STATIC_COLOR, 
            text: "Static Color", 
            description: "Use a specified static color."
        },
        {
            value: ColorizeSourceType.CHAR_COLOR_OVERRIDE, 
            text: "Per-Character Only", 
            description: "Use the default quote color except for characters with a specified override color."},
    ];

    return createDropdownWithLabel(id, options, "Color Source", "The source to use for dialogue color.", onChangedCallback);
}

/**
 * 
 * @param {string} id The ID to set on the created elements.
 * @param {((event: Event) => void)=} onChangedCallback The 'onchange' callback to add to the dropdown.
 * @returns {HTMLDivElement} The div containing the label and dropdown.
 */
export function createColorTargetDropdown(id, onChangedCallback) {
    /** @type {DropdownOptionObject[]} */
    const options = [
        {
            value: ColorizeTargetType.BUBBLES, 
            text: "Chat Bubbles", 
            description: "Color the chat bubbles. Only works with the 'Bubbles' chat style." 
        },
        {
            value: ColorizeTargetType.QUOTED_TEXT, 
            text: "Quoted Text", 
            description: "Color quoted text." 
        },
        {
            value: ColorizeTargetType.QUOTED_TEXT_AND_BUBBLES, 
            text: "All", 
            description: "Color both chat bubbles and quoted text." 
        },
    ];

    return createDropdownWithLabel(id, options, "Color Targets", "Which elements to color.", onChangedCallback);
} 
 
ExColor.js 
/**
 * @typedef {[number, number, number, number?]} ColorArray
 */

/**
 * @typedef {object} RgbaObject
 * @property {number} r - The red value (0-255).
 * @property {number} g - The green value (0-255).
 * @property {number} b - The blue value (0-255).
 * @property {number=} a - The alpha value (0-255).
 */

/**
 * @typedef {object} HslaObject
 * @property {number} h - The hue value (0-1).
 * @property {number} s - The saturation value (0-1).
 * @property {number} l - The luminosity value (0-1).
 * @property {number=} a - The alpha value (0-1).
 */

/**
 * Provides many utility methods to convert between color representations.
 */
export class ExColor {
    /** @type {ColorArray?} */ #rgba;
    /** @type {ColorArray?} */ #hsla;
    /** @type {String?} */ #hex;

    /**
     * @hideconstructor 
     * Use the static constructor functions `ExColor.fromRgb()` and `ExColor.fromHsl()` instead.
     * 
     * Creates a new `ExColor` object with the specified RGB values. At least one object must be provided.
     * 
     * @param {ColorArray | RgbaObject | null} rgba An array of numbers `[r, g, b, a?]` or an object `{ r: number, g: number, b: number, a?: number }`. 
     * Numbers should be within the range `0-255`.
     * 
     * @param {ColorArray | HslaObject | null} hsla An array of numbers `[h, s, l, a?]` or an object `{ h: number, s: number, l: number, a?: number }`. 
     * Numbers should be within the range `0-1`.
     * 
     * 
     * The only validation done is checking for an array or an object for performance reasons.
     */
    constructor(rgba, hsla) {
        if (!rgba && !hsla)
            throw new Error(`No arguments provided to constructor.`);

        if (rgba) {
            if (Array.isArray(rgba)) {
                this.#rgba = rgba;
            } else if (typeof rgba === 'object') {
                this.#rgba = [rgba.r, rgba.g, rgba.b, rgba.a];
            } else {
                throw new TypeError(`Unsupported data type '${typeof rgba}'.`);
            }
        }

        if (hsla) {
            if (Array.isArray(hsla)) {
                this.#hsla = hsla;
            } else if (typeof hsla === 'object') {
                this.#hsla = [hsla.h, hsla.s, hsla.l, hsla.a];
            } else {
                throw new TypeError(`Unsupported data type '${typeof hsla}'.`);
            }
        }
    }

    /**
     * 
     * @returns {RgbaObject}
     */
    toRgb() {
        if (!this.#rgba) {
            this.#rgba = ExColor.hsl2rgb(this.#hsla);
        }
        
        const [r, g, b, a] = this.#rgba;
        return {r, g, b, a};
    }

    /**
     * 
     * @returns {HslaObject}
     */
    toHsl() {
        if (!this.#hsla) {
            this.#hsla = ExColor.rgb2hsl(this.#rgba);
        }

        const [h, s, l, a] = this.#hsla;
        return {h, s, l, a};
    }

    /**
     * Converts this color value to a hex color string. The resulting string does not have a leading hash `#`.
     * 
     * @param {boolean} shortform If `true`, will return a shortform version of the hex color if possible.
     * @returns {string}
     */
    toHex(shortform = false) {
        if (!this.#hex) {
            if (!this.#rgba) {
                this.#rgba = ExColor.hsl2rgb(this.#hsla);
            }

            this.#hex = ExColor.rgb2hex(this.#rgba);
        }

        let hex = this.#hex;
        if (shortform) {
            hex = ExColor.hexLongToShort(hex) || hex;
        }

        return hex;
    }

    /**
     * Creates a new `ExColor` object from the specified RGBA values.
     * 
     * @param {ColorArray | RgbaObject} rgba An array of numbers `[r, g, b, a?]` or an object `{ r: number, g: number, b: number, a?: number }`. 
     * Numbers should be within the range `0-255`.
     * 
     * The only validation done is checking for an array or an object for performance reasons.
     * 
     * @returns {ExColor}
     */
    static fromRgb(rgba) {
        return new ExColor(rgba, null);
    }
    
    /**
     * Creates a new `ExColor` object from the specified HSLA values.
     * 
     * @param {ColorArray | HslaObject} hsla An array of numbers `[h, s, l, a?]` or an object `{ h: number, s: number, l: number, a?: number }`. 
     * Numbers should be within the range `0-1`.
     * 
     * The only validation done is checking for an array or an object for performance reasons.
     * 
     * @returns {ExColor}
     */
    static fromHsl(hsla) {
        return new ExColor(null, hsla);
    }

    /**
     * Creates a new `ExColor` object from the specified hex color value.
     * 
     * @param {string} hex A string with an optional leading hash `#`, followed by exactly three or six hexadecimal characters.
     * @param {number=} alpha An optional alpha value between `0-255`.
     * 
     * The only validation done is checking for an array or an object for performance reasons.
     * 
     * @returns {ExColor}
     */
    static fromHex(hex, alpha) {
        const rgba = ExColor.hex2rgb(hex, alpha);
        return new ExColor(rgba, null);
    }

    /**
     * Converts the specified RGBA values to HSLA. The alpha value is scaled to fit the resulting range.
     * 
     * @param {ColorArray | RgbaObject} rgba An array of numbers `[r, g, b, a?]` or an object `{ r: number, g: number, b: number, a?: number }`.
     * Numbers should be within the range `0-255`.
     * 
     * @returns {ColorArray} The resulting HSLA values, in the range `0-1`.
     */
    static rgb2hsl(rgba) {
        let r, g, b, a;
        if (Array.isArray(rgba)) {
            [r, g, b, a = 255] = rgba;
        } else if (typeof rgba === 'object') {
            [r, g, b, a = 255] = [rgba.r, rgba.g, rgba.b, rgba.a];
        } else {
            throw new TypeError(`Unsupported data type '${typeof rgba}'.`);
        }

        r /= 255;
        g /= 255;
        b /= 255;
        a /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const maxMin = (max + min);

        let h, s, l = maxMin / 2;
        if (max !== min) {
            let d = max - min;
            s = l > 0.5 ? d / (2 - d) : d / maxMin;

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4;
            }

            h /= 6;
        } else { // achromatic
            h = s = 0;
        }

        return [h, s, l, a];
    }

    /**
     * Converts the specified HSLA values to RGBA. The alpha value is scaled to fit the resulting range.
     * 
     * @param {ColorArray | HslaObject} hsla An array of numbers `[h, s, l, a?]` or an object `{ h: number, s: number, l: number, a?: number }`.
     * Numbers should be within the range `0-1`.
     * 
     * @returns {ColorArray} The resulting RGBA values, in the range `0-255`.
     */
    static hsl2rgb(hsla) {
        let h, s, l, a;
        if (Array.isArray(hsla)) {
            [h, s, l, a = 1] = hsla;
        } else if (typeof hsla === 'object') {
            [h, s, l, a = 1] = [hsla.h, hsla.s, hsla.l, hsla.a];
        } else {
            throw new TypeError(`Unsupported data type '${typeof hsla}'.`);
        }

        let r, g, b;
        if (s !== 0) {
            function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            let q = l < 0.5 
                ? l * (1 + s) 
                : l + s - l * s;
            let p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        } else { // achromatic
            r = g = b = l;
        }

        r = Math.round(r * 255);
        g = Math.round(g * 255);
        b = Math.round(b * 255);
        a = Math.round(a * 255);
        return [r, g, b, a];
    }

    /**
     * Converts the specified RGB value into a hex color string. The resulting string does not have a leading hash `#`.
     * @param {ColorArray | RgbaObject} rgb 
     * @returns {string}
     */
    static rgb2hex(rgb) {
        let r, g, b;
        if (Array.isArray(rgb)) {
            [r, g, b] = rgb;
        } else if (typeof rgb === 'object') {
            [r, g, b] = [rgb.r, rgb.g, rgb.b];
        } else {
            throw new TypeError(`Unsupported data type '${typeof rgb}'.`);
        }

        function num2hex(num) {
            const hex = num.toString(16);
            return hex.length == 1 ? '0' + hex : hex;
        }

        return num2hex(r) + num2hex(g) + num2hex(b);
    }

    /**
     * Converts the specified HSL value into a hex color string. The resulting string does not have a leading hash `#`.
     * 
     * This function works by first converting to RGB.
     * 
     * @param {ColorArray | HslaObject} hsl 
     * @returns {string}
     */
    static hsl2hex(hsl) {
        let rgb = ExColor.hsl2rgb(hsl);
        return ExColor.rgb2hex(rgb);
    }

    /**
     * Converts the specified hex color value into an RGB value. Does not support alpha.
     * 
     * @param {string} hex A string with an optional leading hash `#` followed by exactly three or six hexadecimal characters.
     * @param {number=} alpha An optional alpha value between `0-255`.
     * @returns {ColorArray}
     */
    static hex2rgb(hex, alpha) {
        hex = this.#hexNormalize(hex);
        if (hex.length === 3) hex = ExColor.hexShortToLong(hex);

        let r = parseInt(hex.slice(0, 2), 16);
        let g = parseInt(hex.slice(2, 4), 16);
        let b = parseInt(hex.slice(4, 6), 16);
        return [r, g, b, alpha];
    }

    /**
     * Gets whether the given object is a valid hex color string. A leading hash `#` is allowed.
     * 
     * @param {any} obj
     * @returns {boolean}
     */
    static isValidHexString(obj) {
        if (typeof obj !== 'string') return false;
        return /^#?(?:[0-9A-F]{3}){1,2}$/i.test(obj);
    }

    /**
     * Returns whether the specified long hex string can be converted to shortform. Returns `true` if the hex string is already short.
     * @param {string} hex
     * @returns {boolean}
     */
    static hexCanBeShort(hex) {
        hex = this.#hexNormalize(hex);
        if (hex.length === 3) return true;

        return hex[0] == hex[1] &&
               hex[2] == hex[3] &&
               hex[4] == hex[5];
    }

    /**
     * @param {string} hex
     * @returns {boolean}
     */
    static hexIsShort(hex) {
        hex = this.#hexNormalize(hex);
        return length === 3;
    }

    /**
     * Converts the specified long hex color string into shortform. 
     * Returns `hex` if it is already short. 
     * Returns `null` if it cannot be represented in shortform.
     * 
     * @param {string} hex
     * @returns {string?}
     */
    static hexLongToShort(hex) {
        hex = this.#hexNormalize(hex);
        if (!this.hexCanBeShort(hex)) return null;
        if (hex.length === 3) return hex;

        return hex[0] + hex [2] + hex[4];
    }

    /**
     * Converts the specified short hex color string into longform.
     * 
     * @param {string} hex
     * @returns {string}
     */
    static hexShortToLong(hex) {
        hex = this.#hexNormalize(hex);
        if (hex.length === 6) return hex;
        
        return hex[0] + hex[0] +
               hex[1] + hex[1] +
               hex[2] + hex[2];
    }

    /**
     * Ensures the given hex string has a leading hash.
     * 
     * @param {string} hex 
     * @returns {string}
     */
    static getHexWithHash(hex) {
        hex = this.#hexNormalize(hex);
        return '#' + hex;
    }

    /**
     * Gets the given hex string without any leading hash.
     * 
     * @param {string} hex 
     * @returns {string}
     */
    static getHexWithoutHash(hex) {
        return this.#hexNormalize(hex);
    }

    /**
     * Trims any beginning hash `#` from the hex string and throws on an invalid hex color string.
     * 
     * @param {any} hex 
     * @returns {string}
     */
    static #hexNormalize(hex) {
        if (!this.isValidHexString(hex)) 
            throw new TypeError("Invalid hex color string.");

        hex = hex.substring(hex.lastIndexOf('#') + 1);
        return hex;
    }
} 
 
index.js 
//#region ST imports

import { eventSource, event_types, saveSettingsDebounced } from "../../../../script.js";
import { extension_settings } from "../../../extensions.js";

//#endregion ST imports

//#region Local imports

import { ExColor } from "./ExColor.js";
import { CharacterType, STCharacter } from "./STCharacter.js";
import { getImageVibrant, getValidSwatch } from "./color-utils.js";
import { createColorSourceDropdown, createColorTargetDropdown, createColorTextPickerCombo } from "./element-creators.js";
import { initializeSettings } from "./settings-utils.js";
import { 
    expEventSource, 
    exp_event_type, 
    getAllPersonas, 
    getCharacterBeingEdited, 
    getCurrentCharacter, 
    getCurrentGroupCharacters, 
    getCurrentPersona, 
    getMessageAuthor, 
    isInAnyChat, 
    isInCharacterChat, 
    isInGroupChat } from "./st-utils.js";
import { setInputColorPickerComboValue } from "./utils.js";

//#endregion Local imports

const DEFAULT_STATIC_DIALOGUE_COLOR_HEX = "#e18a24";
/** @type {[number, number, number]} */
const DEFAULT_STATIC_DIALOGUE_COLOR_RGB = [225, 138, 36];

/**
 * @typedef {ValueOf<typeof ColorizeSourceType>} ColorizeSourceType
 * @readonly
 */
export const ColorizeSourceType = {
    AVATAR_VIBRANT: "avatar_vibrant",
    //AVATAR_DOMINANT: "avatar_dominant",
    CHAR_COLOR_OVERRIDE: "char_color_override",
    STATIC_COLOR: "static_color",
    DISABLED: "disabled"
};

/**
 * @typedef {ValueOf<typeof ColorizeTargetType>} ColorizeTargetType
 * @readonly
 */
export const ColorizeTargetType = {
    QUOTED_TEXT: 1 << 0,
    BUBBLES: 1 << 1,
    QUOTED_TEXT_AND_BUBBLES: (1 << 0) | (1 << 1)
};

/**
 * @typedef {defaultExtSettings} XDCSettings
 */
const defaultCharColorSettings = {
    colorizeSource: ColorizeSourceType.AVATAR_VIBRANT,
    staticColor: DEFAULT_STATIC_DIALOGUE_COLOR_HEX,
    colorOverrides: {},
};
const defaultExtSettings = {
    charColorSettings: defaultCharColorSettings,
    personaColorSettings: defaultCharColorSettings,
    colorizeTargets: ColorizeTargetType.QUOTED_TEXT,
    chatBubbleLightness: 0.15,
};

const extName = "SillyTavern-Dialogue-Colorizer";
const extFolderPath = `scripts/extensions/third-party/${extName}`;
const extSettings = initializeSettings(extName, defaultExtSettings);

/** @type {HTMLStyleElement} */
let charactersStyleSheet;
/** @type {HTMLStyleElement} */
let personasStyleSheet;

/**
 * @param {STCharacter} stChar
 */
async function getCharStyleString(stChar) {
    let styleHtml = "";
    if ((extSettings.colorizeTargets & ColorizeTargetType.QUOTED_TEXT) === ColorizeTargetType.QUOTED_TEXT) {
        const charDialogueColor = await getCharacterDialogueColor(stChar);
        if (charDialogueColor) {
            styleHtml += `
                .mes[xdc-author_uid="${stChar.uid}"] .mes_text q {
                    color: #${charDialogueColor.toHex()};
                }
            `;
        }
    }
    if ((extSettings.colorizeTargets & ColorizeTargetType.BUBBLES) === ColorizeTargetType.BUBBLES) {
        const charBubbleColor = await getCharacterBubbleColor(stChar);
        if (charBubbleColor) {
            styleHtml += `
                .bubblechat .mes[xdc-author_uid="${stChar.uid}"] {
                    background-color: #${charBubbleColor.toHex()} !important;
                    border-color: #${charBubbleColor.toHex()} !important;
                }
            `;
        }
    }

    return styleHtml;
}

/**
 * 
 * @param {STCharacter[]=} characterList 
 */
async function updateCharactersStyleSheet(characterList) {
    if (!characterList) {
        if (!isInAnyChat()) {
            return;
        }
        if (isInGroupChat()) {
            characterList = getCurrentGroupCharacters();
        }
        else if (isInCharacterChat()) {
            characterList = [getCurrentCharacter()];
        }
    }

    const stylesHtml = await Promise.all(characterList.map(async char => await getCharStyleString(char)));
    charactersStyleSheet.innerHTML = stylesHtml.join("");
}

// Handled differently from the chars style sheet so we don't have to do any dirty/complex tricks when a chat has messages
// from a persona the user isn't currently using (otherwise the message color would revert to the default).
/**
 * 
 * @param {STCharacter[]=} personaList 
 */
async function updatePersonasStyleSheet(personaList) {
    personaList ??= getAllPersonas();

    const stylesHtml = await Promise.all(personaList.map(async persona => await getCharStyleString(persona)));
    personasStyleSheet.innerHTML = stylesHtml.join("");
}

/**
 * 
 * @param {STCharacter | CharacterType} charType 
 */
function getSettingsForChar(charType) {
    if (charType instanceof STCharacter) {
        charType = charType.type;
    }
    
    switch (charType) {
        case CharacterType.CHARACTER:
            return extSettings.charColorSettings;
        case CharacterType.PERSONA:
            return extSettings.personaColorSettings;
        default:
            console.warn(`Character type '${charType}' has no settings key, using defaults.`);
            return structuredClone(defaultCharColorSettings);
    }
}

/**
 * 
 * @param {import("./ExColor.js").ColorArray} rgb 
 * @returns {import("./ExColor.js").ColorArray}
 */
function makeBetterContrast(rgb) {
    const [h, s, l, a] = ExColor.rgb2hsl(rgb);

    // TODO: Very arbitrary and probably doesn't really make sense.
    // Change this?
    const nHue = h;
    const nSat = s > 0.5 ? s - 0.1 : s + 0.3;
    const nLum = l > 0.7 ? l : 0.7;

    return ExColor.hsl2rgb([nHue, nSat, nLum, a]);
}

/**
 *  
 * @param {HTMLImageElement} image 
 * @param  {...(keyof VibrantSwatches)} swatchKeys 
 * @returns {Promise<[number, number, number]?>}
 */
async function getVibrantColorRgb(image, ...swatchKeys) {
    const vibrant = await getImageVibrant(image);
    const swatch = getValidSwatch(vibrant.swatches(), ...swatchKeys);
    return swatch?.getRgb();
}

let avatarVibrantColorCache = {};
/**
 * 
 * @param {STCharacter} stChar 
 * @returns {Promise<ExColor?>}
 */
async function getCharacterDialogueColor(stChar) {
    const colorSettings = getSettingsForChar(stChar);
    const colorizeSource = Object.keys(colorSettings.colorOverrides).includes(stChar.avatarName)
        ? ColorizeSourceType.CHAR_COLOR_OVERRIDE
        : colorSettings.colorizeSource;

    switch (colorizeSource) {
        case ColorizeSourceType.AVATAR_VIBRANT: {
            if (avatarVibrantColorCache[stChar.uid]) {
                return avatarVibrantColorCache[stChar.uid];
            }
            const avatar = stChar.getAvatarImageThumbnail();
            const colorRgb = await getVibrantColorRgb(avatar, "Vibrant", "Muted");
            const betterContrastRgb = colorRgb ? makeBetterContrast(colorRgb) : DEFAULT_STATIC_DIALOGUE_COLOR_RGB;
            const exColor = ExColor.fromRgb(betterContrastRgb);
            avatarVibrantColorCache[stChar.uid] = exColor;
            return exColor;
        }
        case ColorizeSourceType.STATIC_COLOR: {
            return ExColor.fromHex(colorSettings.staticColor);
        }
        case ColorizeSourceType.CHAR_COLOR_OVERRIDE: {
            const overrideColor = colorSettings.colorOverrides[stChar.avatarName];
            return overrideColor ? ExColor.fromHex(overrideColor) : null;
        }
        case ColorizeSourceType.DISABLED:
        default:
            return null;
    }
}

/**
 * 
 * @param {STCharacter} stChar 
 * @returns {Promise<ExColor?>}
 */
async function getCharacterBubbleColor(stChar) {
    const dialogueColor = await getCharacterDialogueColor(stChar);
    if (!dialogueColor) {
        return null;
    }

    const hsl = dialogueColor.toHsl();
    //hsl.s = 0.5;
    hsl.l = extSettings.chatBubbleLightness;

    return ExColor.fromHsl(hsl);
}

/**
 * 
 * @param {string} textboxValue 
 * @param {any} defaultValue 
 * @returns {string | null}
 */
function getTextValidHexOrDefault(textboxValue, defaultValue) {
    const trimmed = textboxValue.trim();
    if (!ExColor.isValidHexString(trimmed))
        return defaultValue;

    return ExColor.getHexWithHash(trimmed);
}

/**
 * 
 * @param {HTMLElement} message 
 */
function addAuthorUidClassToMessage(message) {
    const authorChatUidAttr = "xdc-author_uid";
    if (message.hasAttribute(authorChatUidAttr)) {
        console.debug(`[XDC] Message already has '${authorChatUidAttr}' attribute, skipping.`);
    }

    const messageAuthorChar = getMessageAuthor(message);
    if (!messageAuthorChar) {
        console.error("[XDC] Couldn't get message author character to add class.");
        return;
    }

    message.setAttribute(authorChatUidAttr, messageAuthorChar.uid);
}

//#region Event Handlers

async function onCharacterSettingsUpdated() {
    await updateCharactersStyleSheet();
    saveSettingsDebounced();
}

async function onPersonaSettingsUpdated() {
    await updatePersonasStyleSheet();
    saveSettingsDebounced();
}

async function onAnySettingsUpdated() {
    await updateCharactersStyleSheet();
    await updatePersonasStyleSheet();
    saveSettingsDebounced();
}

/**
 * 
 * @param {STCharacter} char 
 */
function onCharacterChanged(char) {
    const colorOverride = document.getElementById("xdc-char_color_override");
    setInputColorPickerComboValue(colorOverride, extSettings.charColorSettings.colorOverrides[char.avatarName]);
}

/**
 * 
 * @param {STCharacter} persona 
 */
function onPersonaChanged(persona) {
    const colorOverride = document.getElementById("xdc-persona_color_override");
    setInputColorPickerComboValue(colorOverride, extSettings.personaColorSettings.colorOverrides[persona.avatarName]);
}

//#endregion Event Handlers

//#region Initialization

function initializeStyleSheets() {
    charactersStyleSheet = createAndAppendStyleSheet("xdc-chars_style_sheet");
    personasStyleSheet = createAndAppendStyleSheet("xdc-personas_style_sheet");

    function createAndAppendStyleSheet(id) {
        const styleSheet = document.createElement('style');
        styleSheet.id = id;
        return document.body.appendChild(styleSheet);
    }
}

function initializeSettingsUI() {
    const elemExtensionSettings = document.getElementById("xdc-extension-settings");

    const elemGlobalDialogueSettings = elemExtensionSettings.querySelector("#xdc-global_dialogue_settings");
    const elemColorTargetDropdown = createColorTargetDropdown("xdc-global_colorize_target", (changedEvent) => {
        const value = $(changedEvent.target).prop("value");
        extSettings.colorizeTargets = value;
        onAnySettingsUpdated();
    });
    elemGlobalDialogueSettings.children[0].insertAdjacentElement("afterend", elemColorTargetDropdown);
    $(elemColorTargetDropdown.querySelector('select')).prop("value", extSettings.colorizeTargets);

    const elemChatBubbleLightness = elemGlobalDialogueSettings.querySelector("#xdc-chat_bubble_color_lightness");
    $(elemChatBubbleLightness)
        .prop("value", extSettings.chatBubbleLightness)
        .on('focusout', (event) => {
            const target = $(event.target);
            const value = target.prop("value");
            const numValue = parseFloat(value);
            if (Number.isNaN(numValue)) {
                const lastValidValue = target.prop("lastValidValue") || extSettings.chatBubbleLightness;
                target.prop("value", lastValidValue);
                return;
            }

            const resultValue = numValue < 0.0 ? 0.0 
                : numValue > 1.0 ? 1.0 
                : numValue;

            target.prop("value", resultValue);
            extSettings.chatBubbleLightness = resultValue;
            onAnySettingsUpdated();
        });

    const charDialogueSettings = elemExtensionSettings.querySelector("#xdc-char_dialogue_settings");
    const charColorSourceDropdown = createColorSourceDropdown("xdc-char_colorize_source", (changedEvent) => {
        const value = $(changedEvent.target).prop("value");
        extSettings.charColorSettings.colorizeSource = value;
        onCharacterSettingsUpdated();
    });
    const charStaticColorPickerCombo = createColorTextPickerCombo(
        (textboxValue) => getTextValidHexOrDefault(textboxValue, null), 
        (colorValue) => {
            extSettings.charColorSettings.staticColor = colorValue;
            onCharacterSettingsUpdated();
        }
    );
    charDialogueSettings.children[0].insertAdjacentElement("afterend", charColorSourceDropdown);
    charDialogueSettings.children[3].insertAdjacentElement("beforeend", charStaticColorPickerCombo);

    $(charColorSourceDropdown.querySelector('select'))
        .prop("value", extSettings.charColorSettings.colorizeSource)
        .trigger('change');
    $(charStaticColorPickerCombo.querySelector('input[type="text"]'))
        .prop("value", extSettings.charColorSettings.staticColor)
        .trigger('focusout');

    const personaDialogueSettings = elemExtensionSettings.querySelector("#xdc-persona_dialogue_settings");
    const personaColorSourceDropdown = createColorSourceDropdown("xdc-persona_colorize_source", (changedEvent) => {
        const value = $(changedEvent.target).prop("value");
        extSettings.personaColorSettings.colorizeSource = value;
        onPersonaSettingsUpdated();
    });
    
    const personaStaticColorPickerCombo = createColorTextPickerCombo(
        (textboxValue) => getTextValidHexOrDefault(textboxValue, null), 
        (colorValue) => {
            extSettings.personaColorSettings.staticColor = colorValue;
            onPersonaSettingsUpdated();
        }
    );
    personaDialogueSettings.children[0].insertAdjacentElement("afterend", personaColorSourceDropdown);
    personaDialogueSettings.children[3].insertAdjacentElement("beforeend", personaStaticColorPickerCombo);
    
    $(personaColorSourceDropdown.querySelector('select'))
        .prop("value", extSettings.personaColorSettings.colorizeSource)
        .trigger('change');
    $(personaStaticColorPickerCombo.querySelector('input[type="text"]'))
        .prop("value", extSettings.personaColorSettings.staticColor)
        .trigger('focusout');
}

function initializeCharSpecificUI() {
    // Character
    const elemCharColorOverride = createColorOverrideElem("xdc-char_color_override", getCharacterBeingEdited);

    const elemCharCardForm = document.getElementById("form_create");
    const elemAvatarNameBlock = elemCharCardForm.querySelector("div#avatar-and-name-block");
    elemAvatarNameBlock.insertAdjacentElement("afterend", elemCharColorOverride);

    // Persona
    const elemPersonaColorOverride = createColorOverrideElem("xdc-persona_color_override", getCurrentPersona);
    elemPersonaColorOverride.removeChild(elemPersonaColorOverride.querySelector("hr.sysHR")); // eh

    const elemPersonaDescription = document.getElementById("persona_description");
    const elemDescParent = elemPersonaDescription.parentElement;
    elemDescParent.insertAdjacentElement("afterbegin", elemPersonaColorOverride);

    /**
     * 
     * @param {string} id 
     * @param {() => STCharacter} stCharGetter
     */
    function createColorOverrideElem(id, stCharGetter) {
        const label = document.createElement('label');
        label.htmlFor = id;
        label.title = "The color to use for this character's dialogue (quoted text). Overrides the global setting.";
        label.innerHTML = `Dialogue Color<span class="margin5 fa-solid fa-circle-info opacity50p"></span>`;

        const hr = document.createElement('hr');
        hr.className = "sysHR";

        const inputColorPickerCombo = createColorTextPickerCombo(
            (textboxValue) => getTextValidHexOrDefault(textboxValue, ""), 
            (colorValue) => {
                const stChar = stCharGetter();
                const colorSettings = getSettingsForChar(stChar);
                if (colorValue.length > 0)
                    colorSettings.colorOverrides[stChar.avatarName] = colorValue;
                else
                    delete colorSettings.colorOverrides[stChar.avatarName];

                if (stChar.type === CharacterType.PERSONA) {
                    onPersonaSettingsUpdated();
                }
                else {
                    onCharacterSettingsUpdated();
                }
            }
        );

        const wrapper = document.createElement('div');
        wrapper.id = id;
        wrapper.className = "dc-flex-container";
        wrapper.appendChild(hr);
        wrapper.appendChild(label);
        wrapper.appendChild(inputColorPickerCombo);

        return wrapper;
    }
}

jQuery(async ($) => {
    const settingsHtml = await $.get(`${extFolderPath}/dialogue-colorizer.html`);

    const elemStExtensionSettings2 = document.getElementById("extensions_settings2");
    $(elemStExtensionSettings2).append(settingsHtml);

    initializeStyleSheets();
    initializeSettingsUI();
    initializeCharSpecificUI();

    eventSource.on(event_types.CHAT_CHANGED, () => updateCharactersStyleSheet());
    expEventSource.on(exp_event_type.MESSAGE_ADDED, addAuthorUidClassToMessage);

    expEventSource.on(exp_event_type.CHAR_CARD_CHANGED, onCharacterChanged);
    expEventSource.on(exp_event_type.PERSONA_CHANGED, onPersonaChanged);
    
    eventSource.once(event_types.APP_READY, () => {
        onPersonaChanged(getCurrentPersona()); // Initialize color inputs with starting values.
        updatePersonasStyleSheet();
    });
})

//#endregion Initialization 
 
LICENSE 
SillyTavern Dialogue Colorizer
MIT License

Copyright (c) 2023 XanadusWorks

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

Vibrant.js
Copyright (c) 2015 Jari Zwarts

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 
manifest.json 
{
    "display_name": "Dialogue Colorizer",
    "loading_order": 1,
    "requires": [],
    "optional": [],
    "js": "index.js",
    "css": "style.css",
    "author": "Xanadus",
    "version": "1.1.1", 
    "homePage": "https://github.com/XanadusWorks/SillyTavern-Dialogue-Colorizer",
    "auto_update": true
} 
 
README.md 
# SillyTavern Dialogue Colorizer

This extension for SillyTavern gives you various options to automatically color quoted text for character and user persona dialogue.

![Colored dialogue example](https://github.com/XanadusWorks/SillyTavern-Dialogue-Colorizer/assets/72997068/75aac07c-34e8-4f66-a4b5-5c9be415fbb6)


## Features

- Change character's quoted text color to a different color, either dynamically based on the character's avatar card, a per-character color, or a simple static color.
- Can change each individual user persona's quoted text color in the same way.
- Character-specific color (set via the character card edit panel or the persona edit panel) overrides the global setting.
- Works for user-to-character chats and group chats!

## Installation and Usage

### Installation

Use ST's inbuilt third-party extension installer button to install. Go to the Extensions tab, then click `Install extension`. Enter the URL of this Github repository, then hit `Save`.

![SillyTavern Extensions > Install extension](https://github.com/XanadusWorks/SillyTavern-Dialogue-Colorizer/assets/72997068/5e3c1537-18c3-4758-9159-446c2b3b52b9)

![Enter Github URL > Save](https://github.com/XanadusWorks/SillyTavern-Dialogue-Colorizer/assets/72997068/83127307-c861-4684-a075-401df5870a18)


### Usage

By default, the extension will be active and will change the color of quoted text within a character chat based on the most vibrant color in the character's avatar image.

You can set a color per-character by opening the character card's edit panel and setting a color in the `Dialogue Color` section via either using the color picker or entering a hex code manually. This color will override the `Color Source` setting in the extension settings. If you no longer want the character-specific color, simply clear the textbox.

The process is similar for user personas: go into the persona tab, select your persona, and set the dialogue color using the picker just above the persona description.

![Dialogue Color setting in the character card edit panel](https://github.com/XanadusWorks/SillyTavern-Dialogue-Colorizer/assets/72997068/d2fdf104-be8e-4a4b-a90e-9bb6719bb6e7)


Note that the character-specific dialogue color is saved to the extension's settings in SillyTavern, *not* the character card.

There are a couple of options to change what color is used for dialogue. Open the Extensions tab and then open the settings for `Dialogue Colorizer`. There are separate settings for characters and personas, but they work in the same way.

**Color Source**: This is how you choose where the color used comes from.  
    1. **Avatar Vibrant**: This dynamically chooses a dialogue color by finding the most 'vibrant' color in the character's avatar, then does some saturation/lightness adjustments to make sure it's readable.  
    2. **Static Color**: This uses the `Static Color` color - set further down in the extension settings - for the character's dialogue (aside from the characters you give a specific color to).  
    3. **Per-Character Only**: This enables the dialogue coloring only for characters where a color is specified. Other characters will use the default SillyTavern quotes color.  

Note that if a character has a color specified in their card settings, that color will always be used instead unless you remove it by clearing the textbox.

**Static Color**: If `Color Source` is set to `Static Color`, this is the color used for character dialogue. Click the color swatch to bring up a color picker or type in a hex code manually.

![Showcase of extension settings](https://github.com/XanadusWorks/SillyTavern-Dialogue-Colorizer/assets/72997068/8c5e1375-3bb2-4070-987d-160bc2811a31)



## Prerequisites

This extension was built on SillyTavern commit [74e5e0e](https://github.com/SillyTavern/SillyTavern/commit/74e5e0e4c0f800651fea7c57604158f552435393) and may not function correctly on older versions.

## Support and Contributions

If you encounter a bug or issue, please file an issue on the GitHub. 

If you'd like to contribute you can send me suggestions through the SillyTavern discord, or you may fork and submit a pull request—though I'll probably be very slow at reviewing and accepting them.  

Beware: the code is rough as it's my first ever project using JS/HTML/CSS.

## License

SillyTavern Dialogue Colorizer is licenced under the [MIT License](./LICENSE).

[Vibrant.js](https://github.com/jariz/vibrant.js/) is licensed under the [MIT License](./LICENSE).
 
 
settings-utils.js 
import { extension_settings } from "../../../extensions.js";
import { ByRef } from "./ByRef.js";

/** @template TSettings */
export class STExtensionSettingsWrapper {
    #settings;

    /**
     * 
     * @param {TSettings} settings
     */
    constructor(settings) {
        if (settings === null || settings === undefined) {
            throw new Error("Settings object is null or undefined; pass in a valid settings object.");
        }

        this.#settings = settings;
    }

    get settings() {
        return this.#settings;
    }

    /**
     * Gets the value of the specified key.
     * 
     * @param {keyof TSettings} key 
     * @returns {TSettings[keyof TSettings]}
     */
    get(key) {
        return this.#settings[key];
    }

    /**
     * Sets a setting to the specified value.
     * 
     * @param {keyof TSettings} key
     * @param {TSettings[keyof TSettings]} value
     */
    set(key, value) {
        this.#settings[key] = value;
    }

    /**
     * Deletes the specified setting.
     * 
     * @param {keyof TSettings} key
     */
    delete(key) {
        delete this.#settings[key];
    }

    /**
     * Create a new settings wrapper by using a {@linkcode ByRef} to initialize the wrapped settings object.
     * 
     * @template TSettings
     * @param {ByRef<TSettings>} refSettings A reference passed-by-reference to a settings object.
     * @param {TSettings=} defaultSettings A default settings object to initialize the passed settings with, if necessary.
     */
    static safeWrap(refSettings, defaultSettings) {
        if (!(refSettings instanceof ByRef)) {
            throw new TypeError("STExtensionSettingsWrapper.safeWrap() requires a ByRef.");
        }

        const savedSettings = refSettings.ref;
        refSettings.ref = Object.assign({}, defaultSettings ?? {}, savedSettings);
        return new this(refSettings.ref);
    }

    /**
     * Wraps the extension settings object for the specified extension.
     * 
     * @template TSettings
     * @param {string} extensionName The name of the extension to wrap the settings of.
     * @param {TSettings=} defaultSettings A default settings object to initialize the extension's settings with, if necessary.
     */
    static wrapSettingsForExtension(extensionName, defaultSettings) {
        /** @type {extension_settings[extensionName]} */
        const byRefSettings = ByRef.createKeyAccessor(extension_settings, extensionName);
        return this.safeWrap(byRefSettings, defaultSettings);
    }
}

/**
 * Ensures the settings dictionary for the specified extension is initialized and then returns it.
 * 
 * @template TSettings
 * @param {string} extensionName 
 * @param {TSettings=} defaultSettings 
 * @returns {TSettings}
 */
export function initializeSettings(extensionName, defaultSettings) {
    const savedSettings = extension_settings[extensionName];
    extension_settings[extensionName] = Object.assign({}, defaultSettings ? structuredClone(defaultSettings) : {}, savedSettings);
    return extension_settings[extensionName];
} 
 
st-utils.js 
import { EventEmitter } from "../../../../lib/eventemitter.js";
import { user_avatar } from "../../../../script.js";
import { getContext } from "../../../extensions.js";
import { power_user } from "../../../power-user.js";
import { STCharacter, CharacterType } from "./STCharacter.js";

//#region Events

export const expEventSource = new EventEmitter();
export const exp_event_type = {
    /**
     * Emitted when the character card panel is changed to a different character. 
     * Receives an {@linkcode STCharacter} object representing the newly-selected character.
     * @param {STCharacter} character An object representing the new character.
     */
    CHAR_CARD_CHANGED: "char_card_changed",
    /**
     * Emitted when a new persona is added to the DOM.
     * Receives an {@linkcode STCharacter} object representing the created persona.
     * @param {STCharacter} persona An object representing the new persona.
     */
    PERSONA_ADDED: "persona_added",
    /**
     * Emitted when a persona is removed from the DOM. 
     * Receives an {@linkcode STCharacter} object representing the removed persona.
     * @param {STCharacter} persona An object representing the removed persona.
     */
    PERSONA_REMOVED: "persona_removed",
    /**
     * Emitted when the user changes persona. 
     * Receives an {@linkcode STCharacter} object representing the newly-selected persona.
     * @param {STCharacter} persona An object representing the selected persona.
     */
    PERSONA_CHANGED: "persona_changed",
    /**
     * Emitted when a message is added to the chat.
     * Receives the message element that was added.
     * @param {HTMLElement} addedMessage
     */
    MESSAGE_ADDED: "message_added",
    /**
     * Emitted when a message is removed from the chat.
     * Receives the message element that was removed.
     * @param {HTMLElement} removedMessage
     */
    MESSAGE_REMOVED: "message_removed",
};

/**
 * 
 * @param {MutationRecord[]} mutationList 
 * @param {MutationObserver} observer 
 */
function onCharCardChanged(mutationList, observer) {
    for (const mutation of mutationList) {
        const target = /** @type {HTMLElement} */ (mutation.target);

        const avatarFilePath = target.getAttribute("value");
        if (!avatarFilePath) {
            continue;
        }

        const stChar = STCharacter.fromAvatar(CharacterType.CHARACTER, avatarFilePath);
        expEventSource.emit(exp_event_type.CHAR_CARD_CHANGED, stChar);
    }
}

/**
 * 
 * @param {MutationRecord[]} mutationList 
 * @param {MutationObserver} observer 
 */
function onPersonasChanged(mutationList, observer) {
    for (const mutation of mutationList) {
        const target = /** @type {HTMLElement} */ (mutation.target);
        if (mutation.type === "attributes") {
            if (!target.classList.contains("selected")) {
                continue;
            }
            
            const stChar = getSTCharFromAvatarElem(target);
            if (!stChar) {
                continue;
            }
            expEventSource.emit(exp_event_type.PERSONA_CHANGED, stChar);
        }
        else if (mutation.type === "childList") {
            for (const removedNode of mutation.removedNodes) {
                if (!(removedNode instanceof HTMLElement)) {
                    continue;
                }

                if (!removedNode.classList.contains("avatar")) {
                    continue;
                }

                const stChar = getSTCharFromAvatarElem(removedNode);
                if (!stChar) {
                    continue;
                }
                expEventSource.emit(exp_event_type.PERSONA_REMOVED, stChar);
            }
            for (const addedNode of mutation.addedNodes) {
                if (!(addedNode instanceof HTMLElement)) {
                    continue;
                }

                if (!addedNode.classList.contains("avatar")) {
                    continue;
                }

                const stChar = getSTCharFromAvatarElem(addedNode);
                if (!stChar) {
                    continue;
                }
                expEventSource.emit(exp_event_type.PERSONA_ADDED, stChar);
            }
        }
    }

    function getSTCharFromAvatarElem(avatarElem) {
        const avatarFilePath = avatarElem.getAttribute("imgfile");
        if (!avatarFilePath) {
            return null;
        }

        const avatarFileName = avatarFilePath.slice(avatarFilePath.lastIndexOf('/') + 1);
        return STCharacter.fromAvatar(CharacterType.PERSONA, avatarFileName);
    }
}

/**
 * 
 * @param {MutationRecord[]} mutationList 
 * @param {MutationObserver} observer 
 */
function onChatChanged(mutationList, observer) {
    for (const mutation of mutationList) {
        for (const removedNode of mutation.removedNodes) {
            if (!(removedNode instanceof HTMLElement)) {
                continue;
            }
            if (!removedNode.classList.contains("mes"))
                continue;

            expEventSource.emit(exp_event_type.MESSAGE_REMOVED, removedNode);
        }
        
        for (const addedNode of mutation.addedNodes) {
            if (!(addedNode instanceof HTMLElement)) {
                continue;
            }
            if (!addedNode.classList.contains("mes"))
                continue;

            expEventSource.emit(exp_event_type.MESSAGE_ADDED, addedNode);
        }
    }
}

//#region charCardChanged

const elemCharCardForm = document.getElementById("form_create");
const elemAvatarUrl = elemCharCardForm.querySelector("input#avatar_url_pole");

const charCardChangedObserver = new MutationObserver(onCharCardChanged);
/** @type {MutationObserverInit} */
const charCardChangedObserverConfig = { attributeFilter: ["value"] };

charCardChangedObserver.observe(elemAvatarUrl, charCardChangedObserverConfig);

//#endregion

//#region personaChanged

const elemUserAvatarBlock = document.getElementById("user_avatar_block");

const personasObserver = new MutationObserver(onPersonasChanged);
/** @type {MutationObserverInit} */
const personasObserverConfig = { subtree: true, attributeFilter: ["class"], childList: true };

personasObserver.observe(elemUserAvatarBlock, personasObserverConfig);

//#endregion

//#region chatChanged

const elemChat = document.getElementById("chat");

const chatObserver = new MutationObserver(onChatChanged);
/** @type {MutationObserverInit} */
const chatObserverConfig = { childList: true };

chatObserver.observe(elemChat, chatObserverConfig);

//#endregion

//#endregion Events

/**
 * Returns a value indicating whether the user is currently in any chat.
 * 
 * @returns {boolean}
 */
export function isInAnyChat() {
    return isInCharacterChat() || isInGroupChat();
}

/**
 * Returns a value indicating whether the user is currently in a user-to-character chat.
 * 
 * @returns {boolean}
 */
export function isInCharacterChat() {
    return !!getContext().characterId;
}

/**
 * Returns a value indicating whether the user is currently in a group chat.
 * 
 * @returns {boolean}
 */
export function isInGroupChat() {
    return !!getContext().groupId;
}

/**
 * Gets all characters as a list of {@linkcode STCharacter} objects.
 * 
 * @returns {STCharacter[]}
 */
export function getAllCharacters() {
    return Object.values(getContext().characters).map(
        (char) => STCharacter.fromAvatar(CharacterType.CHARACTER, char.avatar)
    );
}

/**
 * Gets all of the user's personas as a list of {@linkcode STCharacter} objects.
 * 
 * @returns {STCharacter[]}
 */
export function getAllPersonas() {
    return Object.entries(power_user.personas).map(
        ([avatarId, name]) => STCharacter.fromAvatar(CharacterType.PERSONA, avatarId)
    );
}

/**
 * Gets the user's currently selected persona.
 * @returns {STCharacter}
 */
export function getCurrentPersona() {
    return STCharacter.fromAvatar(CharacterType.PERSONA, user_avatar);
}

/**
 * Gets the current chat character as an {@linkcode STCharacter}.
 * 
 * @returns {STCharacter?} The current character, or `null` if not currently in a user-to-character chat.
 */
export function getCurrentCharacter() {
    const stContext = getContext();
    const currCharIndex = stContext.characterId;
    if (!currCharIndex)
        return null;

    const currCharAvatar = stContext.characters[currCharIndex].avatar;
    return STCharacter.fromAvatar(CharacterType.CHARACTER, currCharAvatar);
}

/**
 * Gets the character members in the current group chat as a list of {@linkcode STCharacter} objects.
 * 
 * @returns {STCharacter[]?} An array containing the characters in the current group chat, or `null` if not currently in a group chat.
 */
export function getCurrentGroupCharacters() {
    const stContext = getContext();
    const currGroupId = stContext.groupId;
    if (!currGroupId)
        return null;

    const currGroup = stContext.groups.find(group => group.id === currGroupId);
    return currGroup.members
        .map(charAvatar => STCharacter.fromAvatar(CharacterType.CHARACTER, charAvatar));
}

const avatarUrlPole = document.getElementById("avatar_url_pole");
/**
 * Gets the character that is currently being or was last edited. This is not necessarily the current character,
 * as a character's card can be edited from a group chat.
 * 
 * @returns {STCharacter}
 */
export function getCharacterBeingEdited() {
    return STCharacter.fromAvatar(CharacterType.CHARACTER, avatarUrlPole.getAttribute("value"));
}

/**
 * Gets the author of the given message as an {@link STCharacter}.
 * 
 * @param {HTMLElement} message 
 * @returns {STCharacter?} The author of the message, or `null` if the author couldn't be determined.
 */
export function getMessageAuthor(message) {
    /** @type {HTMLImageElement} */
    const avatarThumbImg = message.querySelector(".mesAvatarWrapper > .avatar > img");
    const avatarThumbSrc = avatarThumbImg.getAttribute("src");

    const isUser = message.getAttribute("is_user") === "true";
    // workaround for bug(?) in ST ('/sys {msg}' does not set 'is_system' attr to 'true')
    const isSystem = message.getAttribute("is_system") === "true" || avatarThumbSrc === STCharacter.System.avatarImageThumbnailFilePath;

    /** @type {CharacterType} */
    let charType;
    if (isUser)
        charType = CharacterType.PERSONA;
    else if (isSystem)
        charType = CharacterType.SYSTEM;
    else
        charType = CharacterType.CHARACTER;

    const avatarFileName = getAvatarFileNameFromImgSrc(charType, avatarThumbSrc);
    return STCharacter.fromAvatar(charType, avatarFileName);
}

/**
 * @param {CharacterType} charType
 * @param {string} imageSrc
 * @returns {string?}
 */
function getAvatarFileNameFromImgSrc(charType, imageSrc) {
    let split = imageSrc.split('/').pop();
    switch (charType) {
        case CharacterType.CHARACTER:
            const charThumbRegexp = /\?type=avatar&file=(.*)/i;
            const charMatch = split.match(charThumbRegexp)?.at(1);
            return charMatch ? decodeURIComponent(charMatch) : split;
        case CharacterType.PERSONA:
            return split; // TODO: Needs uri decode?
        case CharacterType.SYSTEM:
            return imageSrc;
        default:
            return null;
    }
} 
 
STCharacter.js 
import { getContext } from "../../../extensions.js";
import { power_user } from "../../../power-user.js";
import { stringFormat } from "./utils.js";

/**
 * @typedef {ValueOf<typeof CharacterType>} CharacterType
 * @readonly
 */
export const CharacterType = {
    CHARACTER: "character",
    PERSONA: "persona",
    SYSTEM: "system"
};

const PRIVATE_CTOR_KEY = Symbol();
const SYSTEM_AVATAR_PATH = "img/five.png";
const CharTypeToAvatarSrcFmt = {
    [CharacterType.CHARACTER]: {
        ["thumbnail"]: "/thumbnail?type=avatar&file={0}",
        ["full"]: "/characters/{0}",
    },
    [CharacterType.PERSONA]: {
        ["thumbnail"]: "/User Avatars/{0}",
        ["full"]: "/User Avatars/{0}",
    },
    [CharacterType.SYSTEM]: {
        ["thumbnail"]: SYSTEM_AVATAR_PATH,
        ["full"]: SYSTEM_AVATAR_PATH,
    },
};

/**
 * Represents a SillyTavern character, which can be a character, user persona or the system.
 * Provides a consistent way to get avatar images for any characer type.
 */
export class STCharacter {
    /** @readonly */
    static #systemChar = new STCharacter(PRIVATE_CTOR_KEY, CharacterType.SYSTEM, SYSTEM_AVATAR_PATH);
    
    #charType;
    #avatarName;

    /**
     * Private constructor; use the {@link STCharacter}.from[...] factory methods instead.
     * 
     * @param {symbol} ctorKey 
     * @param {CharacterType} charType 
     * @param {string} avatarName 
     */
    constructor(ctorKey, charType, avatarName) {
        if (ctorKey !== PRIVATE_CTOR_KEY) {
            throw new TypeError("Cannot call private constructor on STCharacter.");
        }

        this.#charType = charType;
        this.#avatarName = avatarName;
    }

    /** Gets the character type. */
    get type() {
        return this.#charType;
    }

    /** Gets the character's avatar file name. */
    get avatarName() {
        return this.#avatarName;
    }

    /** Gets the image file path of the character's avatar. */
    get avatarImageFilePath() {
        const avatarPathFmt = CharTypeToAvatarSrcFmt[this.#charType]["full"];
        return stringFormat(avatarPathFmt, encodeURIComponent(this.#avatarName));
    }
    
    /** Gets the thumbnail image file path of the character's avatar. */
    get avatarImageThumbnailFilePath() {
        const avatarPathFmt = CharTypeToAvatarSrcFmt[this.#charType]["thumbnail"];
        return stringFormat(avatarPathFmt, encodeURIComponent(this.#avatarName));
    }

    /** Gets a unique string identifier with the character's type and avatar name. */
    get uid() {
        return `${this.#charType}|${this.#avatarName}`;
    }

    /** Creates and returns a new image element of the character's avatar. */
    getAvatarImage() {
        return this.#getAvatar(false);
    }

    /** Creates and returns a new image element of the character's thumbnail avatar. */
    getAvatarImageThumbnail() {
        return this.#getAvatar(true);
    }

    /**
     * 
     * @param {boolean} thumbnail 
     */
    #getAvatar(thumbnail) {
        const avatarSrc = thumbnail
            ? this.avatarImageThumbnailFilePath
            : this.avatarImageFilePath;

        const avatarImage = new Image();
        avatarImage.src = avatarSrc;
        return avatarImage;
    }

    /** 
     * Gets the character representing the system. 
     * @readonly
     * */
    static get System() {
        return this.#systemChar;
    }

    /**
     * Creates a new character of the specified type by using `name` to look up the character's avatar name.
     * Prefer using {@linkcode STCharacter.fromAvatar()} where possible.
     * 
     * @param {CharacterType} charType The character type.
     * @param {string} name The character name.
     * @returns {STCharacter}
     */
    static fromName(charType, name) {
        if (!name) {
            throw new Error("Invalid/empty character name.");
        }
        const avatarFileName = getAvatarFileNameFromCharName(charType, name);
        return new STCharacter(PRIVATE_CTOR_KEY, charType, avatarFileName);
    }

    /**
     * Creates a new character of the specified type with the given avatar file name.
     * 
     * @param {CharacterType} charType The character type.
     * @param {string} avatarFileName The avatar file name. This must be the name alone and not a path.
     * @returns {STCharacter}
     */
    static fromAvatar(charType, avatarFileName) {
        validateAvatarName(charType, avatarFileName);
        return new STCharacter(PRIVATE_CTOR_KEY, charType, avatarFileName);
    }
}

/**
 * 
 * @param {CharacterType} charType 
 * @param {string} name 
 * @returns {string}
 */
function getAvatarFileNameFromCharName(charType, name) {
    let avatarFileName;
    switch (charType) {
        case CharacterType.CHARACTER: {
            const character = getContext().characters.find(char => char.name === name);
            if (!character) {
                throw new Error(`Couldn't find '${name}' in character list; is the character list initialized?`);
            }

            avatarFileName = character.avatar;
        }
        case CharacterType.PERSONA: {
            const personaId = Object.keys(power_user.personas).find(avatarId => power_user.personas[avatarId] === name);
            if (!personaId) {
                throw new Error(`Couldn't find '${name}' in persona list.`)
            }

            avatarFileName = personaId;
        }
        case CharacterType.SYSTEM: {
            avatarFileName = SYSTEM_AVATAR_PATH;
        }
        default: {
            throw new Error(`Invalid character type '${charType}'.`);
        }
    }

    return avatarFileName;
}

/**
 * 
 * @param {CharacterType} charType 
 * @param {string} avatarFileName 
 */
function validateAvatarName(charType, avatarFileName) {
    switch (charType) {
        case CharacterType.CHARACTER: {
            if (!getContext().characters.find(char => char.avatar === avatarFileName)) {
                throw new Error(`Couldn't find '${avatarFileName}' in character list; is the character list initialized?`)
            }
            break;
        }
        case CharacterType.PERSONA: {
            if (!Object.keys(power_user.personas).find(avatarId => avatarId === avatarFileName)) {
                throw new Error(`Couldn't find '${avatarFileName}' in persona list.`)
            }
            break;
        }
        case CharacterType.SYSTEM: {
            if (avatarFileName !== SYSTEM_AVATAR_PATH) {
                throw new Error(`Invalid system character avatar name '${avatarFileName}'; expected '${SYSTEM_AVATAR_PATH}'.`);
            }
            break;
        }
        default: {
            throw new Error(`Invalid character type '${charType}'.`);
        }
    }
} 
 
style.css 
.dc-flex-container {
    display: flex;
    flex-flow: column nowrap;
    justify-content: space-evenly;
}

.dc-small-desc {
    font-size: smaller;
    color: darkgray;
    padding: 0;
    margin-bottom: 4px;
}

.dc-radio-desc-inline {
    padding-left: 2.1em;
}

.dc-color-input-combo {
    display: flex;
    align-items: center;
}

.dc-color-picker {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding: 0;
    overflow: hidden;
    width: 150%;
    height: 150%;
    margin: -25%;
}

.dc-color-picker-wrapper {
    /* display: grid;
    align-content: center;
    justify-content: center; */
    overflow: hidden;
    width: 1.5em;
    height: 1.5em;

    margin: 5px;
    border: 1px solid gray;
    border-radius: 20%;
}

.dc-color-picker::-webkit-color-swatch-wrapper, .dc-color-picker::-moz-color-swatch-wrapper {
	padding: 0;
}

.dc-color-picker::-webkit-color-swatch, .dc-color-picker::-moz-color-swatch {
	border: none;
}

.dc-color-settings-group {
    border: 1px solid #333;
    border-radius: 4px;
    padding: 8px;
    margin: 4px;
    margin-top: 0; /* Stops settings dropdown from 'jumping'. */
} 
 
types.d.ts 
type ValueOf<T> = T[keyof T]; 
 
utils.js 
import { ExColor } from "./ExColor.js";

/**
 * C#-style string format. Does not support named arguments.
 * 
 * @param {string} str
 * @param {any[]} args
 * 
 * @link https://stackoverflow.com/a/8463429
 */
export function stringFormat(str, ...args) {
    return str.replace(/\{\{|\}\}|\{(\d+)\}/g, function (curlyBrack, index) {
        return ((curlyBrack == "{{") ? "{" : ((curlyBrack == "}}") ? "}" : args[index]));
    });
}

/**
 * Loads an image from the specified url.
 * 
 * @param {string} url 
 * @returns {Promise<HTMLImageElement>}
 */
export function loadImage(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.addEventListener('load', () => resolve(img), { once: true });
        img.addEventListener('error', reject, { once: true });
        img.src = url;
    });
}

/**
 * Ensures that the given image is fully loaded.
 * 
 * @param {HTMLImageElement} img 
 * @returns {Promise<HTMLImageElement>}
 */
export function waitForImage(img) {
    return new Promise((resolve, reject) =>
    {
        img.addEventListener('load', () => resolve(img), { once: true });
        img.addEventListener('error', reject, { once: true });
        if (img.complete)
            resolve(img);
    });
}

/**
 * Loads a script from a URI.
 * 
 * @param {string} scriptUri 
 * 
 * @returns {Promise<void>}
 */
export function loadScript(scriptUri) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.type = "text/javascript";
        script.async = true;

        script.addEventListener('load', () => {
            script.parentNode.removeChild(script);
            resolve();
        }, { once: true });
        
        script.addEventListener('error', (err) => {
            script.parentNode.removeChild(script);
            reject(err);
        }, { once: true });

        script.src = scriptUri;
        document.body.appendChild(script);
    });
}

/**
 * @param {string} groupName
 * @returns {HTMLInputElement}
 */
export function getCheckedRadioButtonInGroup(groupName) {
    // @ts-ignore
    return document.querySelector(`input[type="radio"][name="${groupName}"]:checked`).value;
}

/**
 * 
 * @param {string} groupName 
 * @param {string} value 
 * @returns {HTMLInputElement}
 */
export function getRadioButtonInGroup(groupName, value) {
    return document.querySelector(`input[type="radio"][name="${groupName}"][value="${value}"]`);
}

/**
 * @param {string} groupName
 * @returns {NodeListOf<HTMLInputElement>}
 */
export function getAllRadioButtonsInGroup(groupName) {
    return document.querySelectorAll(`input[type="radio"][name="${groupName}"]`)
}

/**
 * 
 * @param {HTMLInputElement} picker 
 * @param {HTMLInputElement} textbox 
 * @param {(textboxValue: string) => string?} textboxValueProcessor 
 * @param {(colorValue: string) => void} onSuccess 
 */
export function linkInputColorTextPicker(picker, textbox, textboxValueProcessor, onSuccess) {
    // Using .addEventListener was not seeming to work correctly, so I swapped to JQuery. 
    // It was probably an error on my part.
    $(picker).on('change', () => {
        const pickerValue = picker.value;
        const textValue = convertColorPickerValueToTextValue(pickerValue);

        textbox.value = textValue;
        textbox.setAttribute("lastValidValue", textValue);

        onSuccess(pickerValue);
    });

    $(textbox).on('focusout', () => {
        let textboxValue = textboxValueProcessor(textbox.value);
        if (textboxValue === null) {
            const lastValidValue = textbox.getAttribute("lastValidValue") ?? picker.value;
            textbox.value = lastValidValue;
            textbox.setAttribute("lastValidValue", lastValidValue);
            return;
        }

        let pickerValue = "#000000";
        if (textboxValue.length !== 0) 
            pickerValue = '#' + ExColor.hexShortToLong(textboxValue);

        textbox.value = textboxValue;
        textbox.setAttribute("lastValidValue", textboxValue);
        picker.value = pickerValue;

        onSuccess(textboxValue);
    });
}

/**
 * Sets the values of the text and color inputs of a combo picker.
 * 
 * @param {HTMLElement} elemComboWrapper 
 * @param {string?} hexValue 
 */
export function setInputColorPickerComboValue(elemComboWrapper, hexValue) {
    const textInput = /** @type {HTMLInputElement} */ (elemComboWrapper.querySelector(`input[type="text"]`));
    const colorInput =/** @type {HTMLInputElement} */ (elemComboWrapper.querySelector(`input[type="color"]`));
    
    textInput.value = hexValue ?? "";
    colorInput.value = hexValue ?? "#000000";
}

/**
 * Assumes a value directly taken from a color picker value property.
 * 
 * @param {string} pickerHexValue 
 */
function convertColorPickerValueToTextValue(pickerHexValue) {
    if (pickerHexValue === undefined) 
        throw new TypeError("Picker hex string value is undefined.");

    if (ExColor.hexCanBeShort(pickerHexValue)) 
        pickerHexValue = '#' + ExColor.hexLongToShort(pickerHexValue);

    return pickerHexValue;
}

/**
 * Assumes a value directly taken from a textbox value property. 
 * 
 * Returns `null` on invalid hex values.  
 * Returns `#000000` on empty string.
 * 
 * @param {string?} textHexValue 
 */
function convertColorTextValueToPickerValue(textHexValue) {
    if (textHexValue === undefined || textHexValue === null) 
        return null;

    textHexValue = textHexValue.trim();
    if (textHexValue.length === 0) 
        return "#000000";
    if (!ExColor.isValidHexString(textHexValue)) 
        return null;

    textHexValue = '#' + ExColor.hexShortToLong(textHexValue);
    return textHexValue;
} 
 
Vibrant.d.ts 
type Tuple<T, N extends number, TArr extends T[] = []> = 
    number extends N ? T[] : TArr['length'] extends N ? TArr : Tuple<T, N, [T, ...TArr]>;

type Maybe<T> = T | undefined;

interface VibrantConstructor {
    /**
     * @param image
     * @param [paletteNumberCount=64]
     * @param [quality=5] 
     */
    new (image: HTMLImageElement!, paletteNumberCount?: number = 64, quality?: number = 5): VibrantObj;
}

interface VibrantObj {
    swatches(): VibrantSwatches;
}

interface VibrantSwatches {
    Vibrant: Maybe<VibrantSwatch>;
    Muted: Maybe<VibrantSwatch>;
    DarkVibrant: Maybe<VibrantSwatch>;
    DarkMuted: Maybe<VibrantSwatch>;
    LightVibrant: Maybe<VibrantSwatch>;
    LightMuted: Maybe<VibrantSwatch>;
};

interface VibrantSwatch {
    //new (rgb: Tuple<number, 3>, population: number): VibrantSwatch;

    getRgb(): Tuple<number, 3>;
    getHsl(): Tuple<number, 3>;
    getHex(): string;
    getPopulation(): number;
    getTitleTextColor(): string;
    getBodyTextColor(): string;
} 
 
Vibrant.min.js 
!function t(r,o,i){function n(a,h){if(!o[a]){if(!r[a]){var u="function"==typeof require&&require;if(!h&&u)return u(a,!0);if(e)return e(a,!0);var s=new Error("Cannot find module '"+a+"'");throw s.code="MODULE_NOT_FOUND",s}var c=o[a]={exports:{}};r[a][0].call(c.exports,function(t){var o=r[a][1][t];return n(o?o:t)},c,c.exports,t,r,o,i)}return o[a].exports}for(var e="function"==typeof require&&require,a=0;a<i.length;a++)n(i[a]);return n}({1:[function(t,r,o){if(!i)var i={map:function(t,r){var o={};return r?t.map(function(t,i){return o.index=i,r.call(o,t)}):t.slice()},naturalOrder:function(t,r){return r>t?-1:t>r?1:0},sum:function(t,r){var o={};return t.reduce(r?function(t,i,n){return o.index=n,t+r.call(o,i)}:function(t,r){return t+r},0)},max:function(t,r){return Math.max.apply(null,r?i.map(t,r):t)}};var n=function(){function t(t,r,o){return(t<<2*s)+(r<<s)+o}function r(t){function r(){o.sort(t),i=!0}var o=[],i=!1;return{push:function(t){o.push(t),i=!1},peek:function(t){return i||r(),void 0===t&&(t=o.length-1),o[t]},pop:function(){return i||r(),o.pop()},size:function(){return o.length},map:function(t){return o.map(t)},debug:function(){return i||r(),o}}}function o(t,r,o,i,n,e,a){var h=this;h.r1=t,h.r2=r,h.g1=o,h.g2=i,h.b1=n,h.b2=e,h.histo=a}function n(){this.vboxes=new r(function(t,r){return i.naturalOrder(t.vbox.count()*t.vbox.volume(),r.vbox.count()*r.vbox.volume())})}function e(r){var o,i,n,e,a=1<<3*s,h=new Array(a);return r.forEach(function(r){i=r[0]>>c,n=r[1]>>c,e=r[2]>>c,o=t(i,n,e),h[o]=(h[o]||0)+1}),h}function a(t,r){var i,n,e,a=1e6,h=0,u=1e6,s=0,p=1e6,f=0;return t.forEach(function(t){i=t[0]>>c,n=t[1]>>c,e=t[2]>>c,a>i?a=i:i>h&&(h=i),u>n?u=n:n>s&&(s=n),p>e?p=e:e>f&&(f=e)}),new o(a,h,u,s,p,f,r)}function h(r,o){function n(t){var r,i,n,e,a,h=t+"1",u=t+"2",c=0;for(s=o[h];s<=o[u];s++)if(v[s]>A/2){for(n=o.copy(),e=o.copy(),r=s-o[h],i=o[u]-s,a=i>=r?Math.min(o[u]-1,~~(s+i/2)):Math.max(o[h],~~(s-1-r/2));!v[a];)a++;for(c=T[a];!c&&v[a-1];)c=T[--a];return n[u]=a,e[h]=n[u]+1,[n,e]}}if(o.count()){var e=o.r2-o.r1+1,a=o.g2-o.g1+1,h=o.b2-o.b1+1,u=i.max([e,a,h]);if(1==o.count())return[o.copy()];var s,c,p,f,l,A=0,v=[],T=[];if(u==e)for(s=o.r1;s<=o.r2;s++){for(f=0,c=o.g1;c<=o.g2;c++)for(p=o.b1;p<=o.b2;p++)l=t(s,c,p),f+=r[l]||0;A+=f,v[s]=A}else if(u==a)for(s=o.g1;s<=o.g2;s++){for(f=0,c=o.r1;c<=o.r2;c++)for(p=o.b1;p<=o.b2;p++)l=t(c,s,p),f+=r[l]||0;A+=f,v[s]=A}else for(s=o.b1;s<=o.b2;s++){for(f=0,c=o.r1;c<=o.r2;c++)for(p=o.g1;p<=o.g2;p++)l=t(c,p,s),f+=r[l]||0;A+=f,v[s]=A}return v.forEach(function(t,r){T[r]=A-t}),n(u==e?"r":u==a?"g":"b")}}function u(t,o){function u(t,r){for(var o,i=1,n=0;p>n;)if(o=t.pop(),o.count()){var e=h(s,o),a=e[0],u=e[1];if(!a)return;if(t.push(a),u&&(t.push(u),i++),i>=r)return;if(n++>p)return}else t.push(o),n++}if(!t.length||2>o||o>256)return!1;var s=e(t),c=0;s.forEach(function(){c++});var l=a(t,s),A=new r(function(t,r){return i.naturalOrder(t.count(),r.count())});A.push(l),u(A,f*o);for(var v=new r(function(t,r){return i.naturalOrder(t.count()*t.volume(),r.count()*r.volume())});A.size();)v.push(A.pop());u(v,o-v.size());for(var T=new n;v.size();)T.push(v.pop());return T}var s=5,c=8-s,p=1e3,f=.75;return o.prototype={volume:function(t){var r=this;return(!r._volume||t)&&(r._volume=(r.r2-r.r1+1)*(r.g2-r.g1+1)*(r.b2-r.b1+1)),r._volume},count:function(r){var o=this,i=o.histo;if(!o._count_set||r){var n,e,a,h,u=0;for(n=o.r1;n<=o.r2;n++)for(e=o.g1;e<=o.g2;e++)for(a=o.b1;a<=o.b2;a++)h=t(n,e,a),u+=i[h]||0;o._count=u,o._count_set=!0}return o._count},copy:function(){var t=this;return new o(t.r1,t.r2,t.g1,t.g2,t.b1,t.b2,t.histo)},avg:function(r){var o=this,i=o.histo;if(!o._avg||r){var n,e,a,h,u,c=0,p=1<<8-s,f=0,l=0,A=0;for(e=o.r1;e<=o.r2;e++)for(a=o.g1;a<=o.g2;a++)for(h=o.b1;h<=o.b2;h++)u=t(e,a,h),n=i[u]||0,c+=n,f+=n*(e+.5)*p,l+=n*(a+.5)*p,A+=n*(h+.5)*p;c?o._avg=[~~(f/c),~~(l/c),~~(A/c)]:o._avg=[~~(p*(o.r1+o.r2+1)/2),~~(p*(o.g1+o.g2+1)/2),~~(p*(o.b1+o.b2+1)/2)]}return o._avg},contains:function(t){var r=this,o=t[0]>>c;return gval=t[1]>>c,bval=t[2]>>c,o>=r.r1&&o<=r.r2&&gval>=r.g1&&gval<=r.g2&&bval>=r.b1&&bval<=r.b2}},n.prototype={push:function(t){this.vboxes.push({vbox:t,color:t.avg()})},palette:function(){return this.vboxes.map(function(t){return t.color})},size:function(){return this.vboxes.size()},map:function(t){for(var r=this.vboxes,o=0;o<r.size();o++)if(r.peek(o).vbox.contains(t))return r.peek(o).color;return this.nearest(t)},nearest:function(t){for(var r,o,i,n=this.vboxes,e=0;e<n.size();e++)o=Math.sqrt(Math.pow(t[0]-n.peek(e).color[0],2)+Math.pow(t[1]-n.peek(e).color[1],2)+Math.pow(t[2]-n.peek(e).color[2],2)),(r>o||void 0===r)&&(r=o,i=n.peek(e).color);return i},forcebw:function(){var t=this.vboxes;t.sort(function(t,r){return i.naturalOrder(i.sum(t.color),i.sum(r.color))});var r=t[0].color;r[0]<5&&r[1]<5&&r[2]<5&&(t[0].color=[0,0,0]);var o=t.length-1,n=t[o].color;n[0]>251&&n[1]>251&&n[2]>251&&(t[o].color=[255,255,255])}},{quantize:u}}();r.exports=n.quantize},{}],2:[function(t,r,o){(function(){var r,o,i,n=function(t,r){return function(){return t.apply(r,arguments)}},e=[].slice;window.Swatch=o=function(){function t(t,r){this.rgb=t,this.population=r}return t.prototype.hsl=void 0,t.prototype.rgb=void 0,t.prototype.population=1,t.yiq=0,t.prototype.getHsl=function(){return this.hsl?this.hsl:this.hsl=i.rgbToHsl(this.rgb[0],this.rgb[1],this.rgb[2])},t.prototype.getPopulation=function(){return this.population},t.prototype.getRgb=function(){return this.rgb},t.prototype.getHex=function(){return"#"+((1<<24)+(this.rgb[0]<<16)+(this.rgb[1]<<8)+this.rgb[2]).toString(16).slice(1,7)},t.prototype.getTitleTextColor=function(){return this._ensureTextColors(),this.yiq<200?"#fff":"#000"},t.prototype.getBodyTextColor=function(){return this._ensureTextColors(),this.yiq<150?"#fff":"#000"},t.prototype._ensureTextColors=function(){return this.yiq?void 0:this.yiq=(299*this.rgb[0]+587*this.rgb[1]+114*this.rgb[2])/1e3},t}(),window.Vibrant=i=function(){function i(t,i,e){this.swatches=n(this.swatches,this);var a,h,u,s,c,p,f,l,A,v,T,g;"undefined"==typeof i&&(i=64),"undefined"==typeof e&&(e=5),f=new r(t);try{for(l=f.getImageData(),T=l.data,v=f.getPixelCount(),h=[],p=0;v>p;)A=4*p,g=T[A+0],c=T[A+1],u=T[A+2],a=T[A+3],a>=125&&(g>250&&c>250&&u>250||h.push([g,c,u])),p+=e;s=this.quantize(h,i),this._swatches=s.vboxes.map(function(t){return function(t){return new o(t.color,t.vbox.count())}}(this)),this.maxPopulation=this.findMaxPopulation,this.generateVarationColors(),this.generateEmptySwatches()}finally{f.removeCanvas()}}return i.prototype.quantize=t("quantize"),i.prototype._swatches=[],i.prototype.TARGET_DARK_LUMA=.26,i.prototype.MAX_DARK_LUMA=.45,i.prototype.MIN_LIGHT_LUMA=.55,i.prototype.TARGET_LIGHT_LUMA=.74,i.prototype.MIN_NORMAL_LUMA=.3,i.prototype.TARGET_NORMAL_LUMA=.5,i.prototype.MAX_NORMAL_LUMA=.7,i.prototype.TARGET_MUTED_SATURATION=.3,i.prototype.MAX_MUTED_SATURATION=.4,i.prototype.TARGET_VIBRANT_SATURATION=1,i.prototype.MIN_VIBRANT_SATURATION=.35,i.prototype.WEIGHT_SATURATION=3,i.prototype.WEIGHT_LUMA=6,i.prototype.WEIGHT_POPULATION=1,i.prototype.VibrantSwatch=void 0,i.prototype.MutedSwatch=void 0,i.prototype.DarkVibrantSwatch=void 0,i.prototype.DarkMutedSwatch=void 0,i.prototype.LightVibrantSwatch=void 0,i.prototype.LightMutedSwatch=void 0,i.prototype.HighestPopulation=0,i.prototype.generateVarationColors=function(){return this.VibrantSwatch=this.findColorVariation(this.TARGET_NORMAL_LUMA,this.MIN_NORMAL_LUMA,this.MAX_NORMAL_LUMA,this.TARGET_VIBRANT_SATURATION,this.MIN_VIBRANT_SATURATION,1),this.LightVibrantSwatch=this.findColorVariation(this.TARGET_LIGHT_LUMA,this.MIN_LIGHT_LUMA,1,this.TARGET_VIBRANT_SATURATION,this.MIN_VIBRANT_SATURATION,1),this.DarkVibrantSwatch=this.findColorVariation(this.TARGET_DARK_LUMA,0,this.MAX_DARK_LUMA,this.TARGET_VIBRANT_SATURATION,this.MIN_VIBRANT_SATURATION,1),this.MutedSwatch=this.findColorVariation(this.TARGET_NORMAL_LUMA,this.MIN_NORMAL_LUMA,this.MAX_NORMAL_LUMA,this.TARGET_MUTED_SATURATION,0,this.MAX_MUTED_SATURATION),this.LightMutedSwatch=this.findColorVariation(this.TARGET_LIGHT_LUMA,this.MIN_LIGHT_LUMA,1,this.TARGET_MUTED_SATURATION,0,this.MAX_MUTED_SATURATION),this.DarkMutedSwatch=this.findColorVariation(this.TARGET_DARK_LUMA,0,this.MAX_DARK_LUMA,this.TARGET_MUTED_SATURATION,0,this.MAX_MUTED_SATURATION)},i.prototype.generateEmptySwatches=function(){var t;return void 0===this.VibrantSwatch&&void 0!==this.DarkVibrantSwatch&&(t=this.DarkVibrantSwatch.getHsl(),t[2]=this.TARGET_NORMAL_LUMA,this.VibrantSwatch=new o(i.hslToRgb(t[0],t[1],t[2]),0)),void 0===this.DarkVibrantSwatch&&void 0!==this.VibrantSwatch?(t=this.VibrantSwatch.getHsl(),t[2]=this.TARGET_DARK_LUMA,this.DarkVibrantSwatch=new o(i.hslToRgb(t[0],t[1],t[2]),0)):void 0},i.prototype.findMaxPopulation=function(){var t,r,o,i,n;for(o=0,i=this._swatches,t=0,r=i.length;r>t;t++)n=i[t],o=Math.max(o,n.getPopulation());return o},i.prototype.findColorVariation=function(t,r,o,i,n,e){var a,h,u,s,c,p,f,l,A;for(s=void 0,c=0,p=this._swatches,a=0,h=p.length;h>a;a++)l=p[a],f=l.getHsl()[1],u=l.getHsl()[2],f>=n&&e>=f&&u>=r&&o>=u&&!this.isAlreadySelected(l)&&(A=this.createComparisonValue(f,i,u,t,l.getPopulation(),this.HighestPopulation),(void 0===s||A>c)&&(s=l,c=A));return s},i.prototype.createComparisonValue=function(t,r,o,i,n,e){return this.weightedMean(this.invertDiff(t,r),this.WEIGHT_SATURATION,this.invertDiff(o,i),this.WEIGHT_LUMA,n/e,this.WEIGHT_POPULATION)},i.prototype.invertDiff=function(t,r){return 1-Math.abs(t-r)},i.prototype.weightedMean=function(){var t,r,o,i,n,a;for(n=1<=arguments.length?e.call(arguments,0):[],r=0,o=0,t=0;t<n.length;)i=n[t],a=n[t+1],r+=i*a,o+=a,t+=2;return r/o},i.prototype.swatches=function(){return{Vibrant:this.VibrantSwatch,Muted:this.MutedSwatch,DarkVibrant:this.DarkVibrantSwatch,DarkMuted:this.DarkMutedSwatch,LightVibrant:this.LightVibrantSwatch,LightMuted:this.LightMuted}},i.prototype.isAlreadySelected=function(t){return this.VibrantSwatch===t||this.DarkVibrantSwatch===t||this.LightVibrantSwatch===t||this.MutedSwatch===t||this.DarkMutedSwatch===t||this.LightMutedSwatch===t},i.rgbToHsl=function(t,r,o){var i,n,e,a,h,u;if(t/=255,r/=255,o/=255,a=Math.max(t,r,o),h=Math.min(t,r,o),n=void 0,u=void 0,e=(a+h)/2,a===h)n=u=0;else{switch(i=a-h,u=e>.5?i/(2-a-h):i/(a+h),a){case t:n=(r-o)/i+(o>r?6:0);break;case r:n=(o-t)/i+2;break;case o:n=(t-r)/i+4}n/=6}return[n,u,e]},i.hslToRgb=function(t,r,o){var i,n,e,a,h,u;return u=void 0,n=void 0,i=void 0,e=function(t,r,o){return 0>o&&(o+=1),o>1&&(o-=1),1/6>o?t+6*(r-t)*o:.5>o?r:2/3>o?t+(r-t)*(2/3-o)*6:t},0===r?u=n=i=o:(h=.5>o?o*(1+r):o+r-o*r,a=2*o-h,u=e(a,h,t+1/3),n=e(a,h,t),i=e(a,h,t-1/3)),[255*u,255*n,255*i]},i}(),window.CanvasImage=r=function(){function t(t){this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),document.body.appendChild(this.canvas),this.width=this.canvas.width=t.width,this.height=this.canvas.height=t.height,this.context.drawImage(t,0,0,this.width,this.height)}return t.prototype.clear=function(){return this.context.clearRect(0,0,this.width,this.height)},t.prototype.update=function(t){return this.context.putImageData(t,0,0)},t.prototype.getPixelCount=function(){return this.width*this.height},t.prototype.getImageData=function(){return this.context.getImageData(0,0,this.width,this.height)},t.prototype.removeCanvas=function(){return this.canvas.parentNode.removeChild(this.canvas)},t}()}).call(this)},{quantize:1}]},{},[2]); 
 
